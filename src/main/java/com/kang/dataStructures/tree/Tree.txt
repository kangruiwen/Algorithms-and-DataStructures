注：下边所有的高度与深度都是从0开始计算：即如果只有一个节点的话，高度与深度都为0
1.树
	ADT：第一个儿子/下一个兄弟表示法：
	class TreeNode {
		Object data;
		TreeNode firstChild;
		TreeNode nextSibling;
	}
2.二叉树
3.二叉查找树
	定义：对于树中每个节点X，它的左子树中所有项的值小于X中的项，而它的右子树中所有项的值大于X中的项。
	平均情况分析：在所有的插入序列都是等可能的情况下，树中的所有节点的平均深度为O(logN).
	最坏情形：在任意连续M此操作，花费的时间为O(MlogN).----这个可能有误
	缺点：树在多次插入操作后容易丧失平衡条件，而导致操作时间上升。
	二叉查找树的应用：
4.AVL树（带有平衡条件的二叉查找树）
	定义：它是一颗空树或者它的两颗子树的高度差的绝对值不超过1，并且左右两颗子树也都是平均二叉树
	性质：在高度为h的AVL树中，最小节点数S(h)由S(h)=S(h-1)+S(h-2)+1给出，函数S(h)与Fibonacci数相关。
	平均情况分析：如果它有n个节点，则它的高度可以保持在log(n),那么它的平均搜索时间复杂度也就是O(log(n))了。
	旋转(rotation):如果树的节点在插入的过程中树的平衡条件遭到破坏，这时就需要旋转对其进行修复。
	破坏树的平衡条件的四种情况：
		1、对a的左儿子的左子树进行一次插入
		2、对a的左儿子的右子树进行一次插入
		3、对a的右儿子的左子树进行一次插入
		4、对a的右儿子的右子树进行一次插入
		针对情况1、4我们使用单旋转：
		针对情况2、3我们使用双旋转：
5.伸展树：
	定义：对于m次连续搜索操作具有很好的效率，伸展树会在一次搜索后对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转来改变树节点的分布，并减小树的深度。
		但伸展树并没有AVL的平衡要求，任意节点的左右子树可以相差任意的深度。与二叉搜索树类似，伸展树的单次搜索也可能需要n此操作，但伸展树可以保证，m次的搜索操作的复杂度为mlog(n)数量级
		而不是m*n数量级
	基本思路：当一个节点被访问后，它就要经过一系列的AVL树的旋转被推到根上。
	具体思路-展开(splaying)：我们仍然从底部向上沿着访问路径旋转。令X是在访问路径上的一个（非根）节点，我们将在这个路径上实施旋转操作。
		1.如果X的父节点是树根，那么只要旋转X和树根。
		2.X有父亲(P)和祖父(G),存在两种情况及对称的情形：
			1：之字形(zig-zag)：X是右儿子，P是左儿子，及对称情形
			2：一字型(zig-zig)：X和P都是左儿子或右儿子
6.B+树：
	定义：阶为M的B+树是一颗具有下列特性的树：
		1、数据项存储在树叶上；
		2、非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中最小的关键字；
		3、树的根或者是一片树叶或者其儿子树在2和M之间
		4、除根外，所有非树叶节点的儿子数在M/2和M之间，其中M/2为：不小于M/2的最小整数
		5、所有的树叶都在相同深度上并有L/2和L之间个数据项
	
	